<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Contains constraints used by the solver."><title>bevy_xpbd_2d::constraints - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bevy_xpbd_2d" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.1 (7cf61ebde 2024-03-27)" data-channel="1.77.1" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../bevy_xpbd_2d/index.html">bevy_xpbd_2d</a><span class="version">0.4.2</span></h2></div><h2 class="location"><a href="#">Module constraints</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#traits">Traits</a></li></ul></section><h2><a href="../index.html">In crate bevy_xpbd_2d</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../bevy_xpbd_2d/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">bevy_xpbd_2d</a>::<wbr><a class="mod" href="#">constraints</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/bevy_xpbd_2d/constraints/mod.rs.html#1-280">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Contains constraints used by the <a href="../plugins/solver/index.html" title="mod bevy_xpbd_2d::plugins::solver">solver</a>.</p>
<h2 id="constraints"><a class="doc-anchor" href="#constraints">§</a>Constraints</h2>
<p><strong>Constraints</strong> are a way to model physical relationships between entities. They are an integral part of XPBD, and they can be used
for things like <a href="penetration/struct.PenetrationConstraint.html" title="struct bevy_xpbd_2d::constraints::penetration::PenetrationConstraint">contact resolution</a>, <a href="joints/index.html" title="mod bevy_xpbd_2d::constraints::joints">joints</a>, soft bodies, and much more.</p>
<p>At its core, a constraint is just a rule that is enforced by moving the participating entities in a way that satisfies that rule.
For example, a distance constraint is satisfied when the distance between two entities is equal to the desired distance.</p>
<p>Most constraints in Bevy XPBD are modeled as seperate entities with a component that implements <a href="trait.XpbdConstraint.html" title="trait bevy_xpbd_2d::constraints::XpbdConstraint"><code>XpbdConstraint</code></a>.
They contain a <code>solve</code> method that receives the states of the participating entities as parameters.
You can find more details on how to use each constraint by taking a look at their documentation.</p>
<p>Below are the currently implemented constraints.</p>
<ul>
<li><a href="penetration/struct.PenetrationConstraint.html" title="struct bevy_xpbd_2d::constraints::penetration::PenetrationConstraint"><code>PenetrationConstraint</code></a></li>
<li><a href="joints/index.html" title="mod bevy_xpbd_2d::constraints::joints">Joints</a>
<ul>
<li><a href="joints/struct.FixedJoint.html" title="struct bevy_xpbd_2d::constraints::joints::FixedJoint"><code>FixedJoint</code></a></li>
<li><a href="joints/struct.DistanceJoint.html" title="struct bevy_xpbd_2d::constraints::joints::DistanceJoint"><code>DistanceJoint</code></a></li>
<li><a href="joints/struct.SphericalJoint.html" title="struct bevy_xpbd_2d::constraints::joints::SphericalJoint"><code>SphericalJoint</code></a></li>
<li><a href="joints/struct.RevoluteJoint.html" title="struct bevy_xpbd_2d::constraints::joints::RevoluteJoint"><code>RevoluteJoint</code></a></li>
<li><a href="joints/struct.PrismaticJoint.html" title="struct bevy_xpbd_2d::constraints::joints::PrismaticJoint"><code>PrismaticJoint</code></a></li>
</ul>
</li>
</ul>
<p>More constraint types will be added in future releases. If you need more constraints now, consider
<a href="#custom-constraints">creating your own constraints</a>.</p>
<h3 id="custom-constraints"><a class="doc-anchor" href="#custom-constraints">§</a>Custom constraints</h3>
<p>In Bevy XPBD, you can easily create your own constraints using the same APIs that the engine uses for its own constraints.</p>
<p>First, create a struct and implement the <a href="trait.XpbdConstraint.html" title="trait bevy_xpbd_2d::constraints::XpbdConstraint"><code>XpbdConstraint</code></a> trait, giving the number of participating entities using generics.
It should look similar to this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy::{ecs::entity::{EntityMapper, MapEntities}, prelude::<span class="kw-2">*</span>};
<span class="kw">use </span>bevy_xpbd_2d::prelude::<span class="kw-2">*</span>;

<span class="kw">struct </span>CustomConstraint {
    entity1: Entity,
    entity2: Entity,
    lagrange: f32,
}

<span class="attr">#[cfg(feature = <span class="string">"f32"</span>)]
</span><span class="kw">impl </span>XpbdConstraint&lt;<span class="number">2</span>&gt; <span class="kw">for </span>CustomConstraint {
    <span class="kw">fn </span>entities(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; [Entity; <span class="number">2</span>] {
        [<span class="self">self</span>.entity1, <span class="self">self</span>.entity2]
    }
    <span class="kw">fn </span>clear_lagrange_multipliers(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
        <span class="self">self</span>.lagrange = <span class="number">0.0</span>;
    }
    <span class="kw">fn </span>solve(<span class="kw-2">&amp;mut </span><span class="self">self</span>, bodies: [<span class="kw-2">&amp;mut </span>RigidBodyQueryItem; <span class="number">2</span>], dt: f32) {
        <span class="comment">// Constraint solving logic goes here
    </span>}
}

<span class="kw">impl </span>MapEntities <span class="kw">for </span>CustomConstraint {
    <span class="kw">fn </span>map_entities&lt;M: EntityMapper&gt;(<span class="kw-2">&amp;mut </span><span class="self">self</span>, entity_mapper: <span class="kw-2">&amp;mut </span>M) {
       <span class="self">self</span>.entity1 = entity_mapper.map_entity(<span class="self">self</span>.entity1);
       <span class="self">self</span>.entity2 = entity_mapper.map_entity(<span class="self">self</span>.entity2);
    }
}</code></pre></div>
<p>Take a look at <a href="trait.XpbdConstraint.html#tymethod.solve" title="method bevy_xpbd_2d::constraints::XpbdConstraint::solve"><code>XpbdConstraint::solve</code></a> and the constraint <a href="#theory">theory</a> to learn more about what to put in <code>solve</code>.</p>
<p>Next, we need to add a system that solves the constraint during each run of the <a href="../plugins/solver/index.html" title="mod bevy_xpbd_2d::plugins::solver">solver</a>. If your constraint is
a component like most of Bevy XPBD’s constraints, you can use the generic <a href="../plugins/solver/fn.solve_constraint.html" title="fn bevy_xpbd_2d::plugins::solver::solve_constraint"><code>solve_constraint</code></a> system that handles
some of the background work for you.</p>
<p>Add the <code>solve_constraint::&lt;YourConstraint, ENTITY_COUNT&gt;</code> system to the
<a href="../struct.SubstepSchedule.html" title="struct bevy_xpbd_2d::SubstepSchedule">substepping schedule’s</a> <a href="../enum.SubstepSet.html#variant.SolveUserConstraints" title="variant bevy_xpbd_2d::SubstepSet::SolveUserConstraints"><code>SubstepSet::SolveUserConstraints</code></a> set. It should look like this:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// Get substep schedule
</span><span class="kw">let </span>substeps = app
    .get_schedule_mut(SubstepSchedule)
    .expect(<span class="string">"add SubstepSchedule first"</span>);

<span class="comment">// Add custom constraint
</span>substeps.add_systems(
    solve_constraint::&lt;CustomConstraint, <span class="number">2</span>&gt;.in_set(SubstepSet::SolveUserConstraints),
);</code></pre></div>
<p>Now just spawn an instance of the constraint, give it the participating entities, and the constraint should be getting
solved automatically according to the <code>solve</code> method!</p>
<p>You can find a working example of a custom constraint
<a href="https://github.com/Jondolf/bevy_xpbd/blob/main/crates/bevy_xpbd_3d/examples/custom_constraint.rs">here</a>.</p>
<h3 id="theory"><a class="doc-anchor" href="#theory">§</a>Theory</h3>
<p>In this section, you can learn some of the theory behind how constraints work. Understanding the theory and maths isn’t
important for using constraints, but it can be useful if you want to <a href="#custom-constraints">create your own constraints</a>.</p>
<p><strong>Note</strong>: In the following theory, primarily the word “particle” is used, but the same logic applies to normal
<a href="../components/enum.RigidBody.html" title="enum bevy_xpbd_2d::components::RigidBody">rigid bodies</a> as well. However, unlike particles, rigid bodies can also have angular quantities such as
<a href="../components/struct.Rotation.html" title="struct bevy_xpbd_2d::components::Rotation">rotation</a> and <a href="../components/struct.Inertia.html" title="struct bevy_xpbd_2d::components::Inertia">angular inertia</a>, so constraints can also affect their orientation. This is explained
in more detail <a href="#rigid-body-constraints">at the end</a>.</p>
<h4 id="constraint-functions"><a class="doc-anchor" href="#constraint-functions">§</a>Constraint functions</h4>
<p>At the mathematical level, each constraint has a <em>constraint function</em> <code>C(x)</code> that takes the state
of the particles as parameters and outputs a scalar value. The goal of the constraint is to move the particles
in a way that the output <em>satisfies</em> a constraint equation.</p>
<p>For <em>equality constraints</em> the equation takes the form <code>C(x) = 0</code>. In other words, the constraint tries to
<em>minimize</em> the value of <code>C(x)</code> to be as close to zero as possible. When the equation is true, the constraint is <em>satisfied</em>.</p>
<p>For a distance constraint, the constraint function would be <code>C(x) = distance - rest_distance</code>,
because this would be zero when the distance is equal to the desired rest distance.</p>
<p>For <em>inequality constraints</em> the equation instead takes the form <code>C(x) &gt;= 0</code>. These constraints are only applied
when <code>C(x) &lt; 0</code>, which is useful for things like static friction and <a href="joints/index.html#joint-limits" title="mod bevy_xpbd_2d::constraints::joints">joint limits</a>.</p>
<h4 id="constraint-gradients"><a class="doc-anchor" href="#constraint-gradients">§</a>Constraint gradients</h4>
<p>To know what directions the particles should be moved towards, constraints compute a <em>constraint gradient</em> <code>▽C(x)</code>
for each particle. It is a vector that points in the direction in which the constraint function value <code>C</code> increases the most.
The length of the gradient indicates how much <code>C</code> changes when moving the particle by one unit. This is often equal to one.</p>
<p>In a case where two particles are being constrained by a distance constraint, and the particles are outside of the
rest distance, the gradient vector would point away from the other particle, because it would increase the distance
even further.</p>
<h4 id="lagrange-multipliers"><a class="doc-anchor" href="#lagrange-multipliers">§</a>Lagrange multipliers</h4>
<p>In the context of constraints, a Lagrange multiplier <code>λ</code> corresponds to the signed magnitude of the constraint force.
It is a scalar value that is the same for all of the constraint’s participating particles, and it is used for computing
the correction that the constraint should apply to the particles along the gradients.</p>
<p>In XPBD, the Lagrange multiplier update <code>Δλ</code> during a substep is computed by dividing the opposite of <code>C</code>
by the sum of the products of the inverse masses and squared gradient lengths plus an additional compliance term:</p>
<div class="example-wrap"><pre class="language-text"><code>Δλ = -C / (sum(w_i * |▽C_i|^2) + α / h^2)
</code></pre></div>
<p>where <code>w_i</code> is the inverse mass of particle <code>i</code>, <code>|▽C_i|</code> is the length of the gradient vector for particle <code>i</code>,
<code>α</code> is the constraint’s compliance (inverse of stiffness) and <code>h</code> is the substep size. Using <code>α = 0</code>
corresponds to infinite stiffness.</p>
<p>The minus sign is there because the gradients point in the direction in which <code>C</code> increases the most,
and we instead want to minimize <code>C</code>.</p>
<p>Note that if the gradients are normalized, as is often the case, the squared gradient lengths can be omitted from the
calculation.</p>
<h4 id="solving-constraints"><a class="doc-anchor" href="#solving-constraints">§</a>Solving constraints</h4>
<p>Once we have computed the Lagrange multiplier <code>λ</code>, we can compute the positional correction for a given particle
as the product of the Lagrange multiplier and the particle’s inverse mass and gradient vector:</p>
<div class="example-wrap"><pre class="language-text"><code>Δx_i = Δλ * w_i * ▽C_i
</code></pre></div>
<p>In other words, we typically move the particle along the gradient by <code>Δλ</code> proportional to the particle’s inverse mass.</p>
<h4 id="rigid-body-constraints"><a class="doc-anchor" href="#rigid-body-constraints">§</a>Rigid body constraints</h4>
<p>Unlike particles, <a href="../components/enum.RigidBody.html" title="enum bevy_xpbd_2d::components::RigidBody">rigid bodies</a> also have angular quantities like <a href="../components/struct.Rotation.html" title="struct bevy_xpbd_2d::components::Rotation">rotation</a>,
<a href="../components/struct.AngularVelocity.html" title="struct bevy_xpbd_2d::components::AngularVelocity">angular velocity</a> and <a href="../components/struct.Inertia.html" title="struct bevy_xpbd_2d::components::Inertia">angular inertia</a>. In addition, constraints can be applied at specific
points in the body, like contact positions or joint attachment positions, which also affects the orientation.</p>
<p>When the constraint is not applied at the center of mass, the inverse mass in the computation of <code>Δλ</code> must
be replaced with a <em>generalized inverse mass</em> that is essentially the effective mass when applying the constraint
at some specified position.</p>
<p>For a positional constraint applied at position <code>r_i</code>, the generalized inverse mass computation for body <code>i</code> looks like this:</p>
<div class="example-wrap"><pre class="language-text"><code>w_i = 1 / m_i + (r_i x ▽C_i)^T * I_i^-1 * (r_i x ▽C_i)
</code></pre></div>
<p>where <code>m_i</code> is the <a href="../components/struct.Mass.html" title="struct bevy_xpbd_2d::components::Mass">mass</a> of body <code>i</code>, <code>I_i^-1</code> is the <a href="../components/struct.InverseInertia.html" title="struct bevy_xpbd_2d::components::InverseInertia">inverse inertia tensor</a>, and <code>^T</code> refers to the
transpose of a vector. Note that the value of the inertia tensor depends on the orientation of the body, so it should be
recomputed each time the constraint is solved.</p>
<p>For an angular constraint where the gradient vector is the rotation axis, the generalized inverse mass computation instead
looks like this:</p>
<div class="example-wrap"><pre class="language-text"><code>w_i = ▽C_i^T * I_i^-1 * ▽C_i
</code></pre></div>
<p>Once we have computed the Lagrange multiplier update, we can apply the positional correction as shown in the
<a href="#solving-constraints">previous section</a>.</p>
<p>However, angular constraints are handled differently. If the constraint function’s value is the rotation angle and
the gradient vector is the rotation axis, we can compute the angular correction for a given body like this:</p>
<div class="example-wrap"><pre class="language-text"><code>Δq_i = 0.5 * [I_i^-1 * (r_i x (Δλ * ▽C_i)), 0] * q_i
</code></pre></div>
<p>where <code>q_i</code> is the <a href="../components/struct.Rotation.html" title="struct bevy_xpbd_2d::components::Rotation">rotation</a> of body <code>i</code> and <code>r_i</code> is a vector pointing from the body’s center of mass to some
attachment position.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><code>pub use <a class="mod" href="joints/index.html" title="mod bevy_xpbd_2d::constraints::joints">joints</a>::*;</code></div></li><li><div class="item-name"><code>pub use <a class="mod" href="penetration/index.html" title="mod bevy_xpbd_2d::constraints::penetration">penetration</a>::*;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="joints/index.html" title="mod bevy_xpbd_2d::constraints::joints">joints</a></div><div class="desc docblock-short"><strong>Joints</strong> are a way to connect entities in a way that restricts their movement relative to each other.
They act as <a href="index.html" title="mod bevy_xpbd_2d::constraints">constraints</a> that restrict different <em>Degrees Of Freedom</em> depending on the joint type.</div></li><li><div class="item-name"><a class="mod" href="penetration/index.html" title="mod bevy_xpbd_2d::constraints::penetration">penetration</a></div><div class="desc docblock-short">Penetration constraint.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.AngularConstraint.html" title="trait bevy_xpbd_2d::constraints::AngularConstraint">AngularConstraint</a></div><div class="desc docblock-short">An angular constraint applies an angular correction around a given axis.</div></li><li><div class="item-name"><a class="trait" href="trait.PositionConstraint.html" title="trait bevy_xpbd_2d::constraints::PositionConstraint">PositionConstraint</a></div><div class="desc docblock-short">A positional constraint applies a positional correction
with a given direction and magnitude at the local contact points <code>r1</code> and  <code>r2</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.XpbdConstraint.html" title="trait bevy_xpbd_2d::constraints::XpbdConstraint">XpbdConstraint</a></div><div class="desc docblock-short">A trait for all XPBD <a href="index.html" title="mod bevy_xpbd_2d::constraints">constraints</a>.</div></li></ul></section></div></main></body></html>