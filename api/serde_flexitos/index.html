<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides types and function for flexible serialization and deserialization of trait objects with serde."><title>serde_flexitos - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="serde_flexitos" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../serde_flexitos/index.html">serde_flexitos</a><span class="version">0.2.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">serde_flexitos</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/serde_flexitos/lib.rs.html#1-355">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides types and function for flexible serialization and deserialization of trait objects with
<a href="https://crates.io/crates/serde">serde</a>.</p>
<h2 id="why"><a class="doc-anchor" href="#why">§</a>Why?</h2>
<p>When you need to treat several types that implement a trait <em>as a single type</em>, a trait object type <code>dyn O</code> is one
of the most convenient solutions in Rust. If you need (de)serialization for such a trait object, this crate can help
provide that.</p>
<h2 id="is-this-not-already-possible"><a class="doc-anchor" href="#is-this-not-already-possible">§</a>Is this not already possible?</h2>
<p>Serializing a trait object is already possible with <a href="https://crates.io/crates/erased-serde">erased-serde</a>’s <a href="../erased_serde/ser/trait.Serialize.html" title="trait erased_serde::ser::Serialize"><code>erased_serde::Serialize</code></a>.
However, erased-serde does not provide a convenient way to <em>deserialize trait objects</em>.</p>
<p>To deserialize a trait object, we first need to figure out the concrete type that was serialized, and then use the
corresponding <a href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize"><code>Deserialize</code></a> implementation of that type to deserialize the value. We cannot use the trait object
type directly to get the corresponding <a href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize"><code>Deserialize</code></a> implementation, because trait objects must be object safe,
ruling out associated functions (only allowing methods: functions that take a <code>&amp;self</code> and variations). But when
deserializing, we do not have an instance of the trait object (we are instantiating it with deserialization!), thus
there is no method to call. Therefore, an external mechanism is needed to get <a href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize"><code>Deserialize</code></a> implementations for
concrete types.</p>
<p>Two other solutions exist (to my knowledge), but they make trade-offs that not everyone is willing to make, and
provide no way to opt-out of those trade-offs:</p>
<ul>
<li><a href="https://crates.io/crates/typetag">typetag</a>: A convenient solution to get (de)serialization for trait objects. However, it uses
<a href="https://crates.io/crates/inventory">inventory</a> to register <a href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize"><code>Deserialize</code></a> implementations, which does not work on every platform (for
example, WASM). It also registers these implementations globally using a procedural macro that has to be applied
to every concrete type. Finally, generic traits and generic impls of traits are not supported.
If you can work within these limitations, <a href="https://crates.io/crates/typetag">typetag</a> is a great crate, and you should probably use it
instead of this one because it is more convenient!</li>
<li><a href="https://crates.io/crates/serde_traitobject">serde_traitobject</a>: An interesting solution that (de)serializes the entire vtable of a trait
object. However, the vtable is not stable across different compilations, changes when you add or remove
implementations of your trait object, and requires nightly Rust. Therefore, this crate is only usable in the very
limited scope of sending trait objects to another process of the same binary, but is very convenient for that
specific use-case.</li>
</ul>
<p>This crate provides types and functions for flexible (de)serialization of trait objects, that do not necessarily
require macros, global registration, nightly rust, nor require your binary not to change, at the cost of some
convenience. However, convenience can be brought back by creating layers on top of this crate, such as a global
registration macro, allowing you to make the trade-off between convenience and flexibility yourself.</p>
<h2 id="how-does-it-work"><a class="doc-anchor" href="#how-does-it-work">§</a>How does it work?</h2>
<p>A trait object is serialized as an id-value pair, also known as the <a href="https://serde.rs/enum-representations.html#externally-tagged">externally tagged enum representation</a>,
where the id is the <em>unique identifier</em> for the concrete type of the value, and the value is serialized using the
trait object’s <a href="../erased_serde/ser/trait.Serialize.html" title="trait erased_serde::ser::Serialize"><code>erased_serde::Serialize</code></a> implementation.</p>
<p>A trait object is deserialized by first deserializing the ID, then finding the <a href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize"><code>Deserialize</code></a> implementation of
the concrete type using that ID, and then deserializing the value with that deserialize impl.</p>
<p>An ID must uniquely identify a concrete type of a trait object, and be stable over time, in order for
deserialization to keep working over time. Missing or duplicate IDs will result in (recoverable) errors during
deserialization.</p>
<h2 id="how-do-i-use-this-crate"><a class="doc-anchor" href="#how-do-i-use-this-crate">§</a>How do I use this crate?</h2>
<p>A <a href="trait.Registry.html" title="trait serde_flexitos::Registry">registry</a> handles registration of <a href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize"><code>Deserialize</code></a> impls and finding them by ID. For each trait object
you wish to deserialize, you must construct a registry and register all concrete types with it. Currently,
<a href="struct.MapRegistry.html" title="struct serde_flexitos::MapRegistry"><code>MapRegistry</code></a> is the only registry implementation.</p>
<p>To <a href="trait.Registry.html#tymethod.register" title="method serde_flexitos::Registry::register">register</a> a concrete type, we must provide:</p>
<ol>
<li>the ID (<code>&amp;'static str</code>) for that concrete type,</li>
<li>a <a href="type.DeserializeFn.html" title="type serde_flexitos::DeserializeFn">deserialize function</a> that deserializes the concrete type as a boxed trait object.</li>
</ol>
<p>Traits must have <a href="../erased_serde/ser/trait.Serialize.html" title="trait erased_serde::ser::Serialize"><code>erased_serde::Serialize</code></a> as a supertrait and have a method to retrieve the ID of the concrete
type. Concrete types of the trait must implement <a href="../serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize"><code>Serialize</code></a>.</p>
<p>Then, you can implement <a href="../serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize"><code>Serialize</code></a> for <code>dyn Trait</code> using  <a href="fn.serialize_trait_object.html" title="fn serde_flexitos::serialize_trait_object"><code>serialize_trait_object</code></a>, and <a href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize"><code>Deserialize</code></a> for
<code>Box&lt;dyn Trait&gt;</code> using <a href="trait.Registry.html#method.deserialize_trait_object" title="method serde_flexitos::Registry::deserialize_trait_object"><code>deserialize_trait_object</code></a>.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>An example, using a global registry to get some convenience:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>once_cell::sync::Lazy;
<span class="kw">use </span>serde::{Deserialize, Deserializer, Serialize, Serializer};

<span class="kw">use </span>serde_flexitos::{MapRegistry, Registry, serialize_trait_object};

<span class="comment">// Trait we want to serialize trait objects of. This example just uses `Debug` as supertrait so we can print values.

</span><span class="kw">pub trait </span>Example: erased_serde::Serialize + std::fmt::Debug {
  <span class="comment">// Gets the ID that uniquely identifies the concrete type of this value. Must be a method for object safety.
  </span><span class="kw">fn </span>id(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str;
}

<span class="comment">// Implementations of the `Example` trait.

</span><span class="attr">#[derive(Clone, Serialize, Deserialize, Debug)]
</span><span class="kw">struct </span>Foo(String);
<span class="kw">impl </span>Foo {
  <span class="kw">const </span>ID: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str = <span class="string">"Foo"</span>;
}
<span class="kw">impl </span>Example <span class="kw">for </span>Foo {
  <span class="kw">fn </span>id(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str { <span class="self">Self</span>::ID }
}

<span class="attr">#[derive(Clone, Serialize, Deserialize, Debug)]
</span><span class="kw">struct </span>Bar(usize);
<span class="kw">impl </span>Bar {
  <span class="kw">const </span>ID: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str = <span class="string">"Bar"</span>;
}
<span class="kw">impl </span>Example <span class="kw">for </span>Bar {
  <span class="kw">fn </span>id(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str { <span class="self">Self</span>::ID }
}

<span class="comment">// Create registry for `Example` and register all concrete types with it. Store in static with `Lazy` to lazily
// initialize it once while being able to create global references to it.

</span><span class="kw">static </span>EXAMPLE_REGISTRY: Lazy&lt;MapRegistry&lt;<span class="kw">dyn </span>Example&gt;&gt; = Lazy::new(|| {
  <span class="kw">let </span><span class="kw-2">mut </span>registry = MapRegistry::&lt;<span class="kw">dyn </span>Example&gt;::new(<span class="string">"Example"</span>);
  registry.register(Foo::ID, |d| <span class="prelude-val">Ok</span>(Box::new(erased_serde::deserialize::&lt;Foo&gt;(d)<span class="question-mark">?</span>)));
  registry.register(Bar::ID, |d| <span class="prelude-val">Ok</span>(Box::new(erased_serde::deserialize::&lt;Bar&gt;(d)<span class="question-mark">?</span>)));
  registry
});

<span class="comment">// (De)serialize implementations

</span><span class="kw">impl</span>&lt;<span class="lifetime">'a</span>&gt; Serialize <span class="kw">for dyn </span>Example + <span class="lifetime">'a </span>{
  <span class="kw">fn </span>serialize&lt;S: Serializer &gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, serializer: S) -&gt; <span class="prelude-ty">Result</span>&lt;S::Ok, S::Error&gt; {
    <span class="comment">// Check that `Example` has `erased_serde::Serialize` as a supertrait, preventing infinite recursion at runtime.
    </span><span class="kw">const fn </span>__check_erased_serialize_supertrait&lt;T: <span class="question-mark">?</span>Sized + Example&gt;() {
      serde_flexitos::ser::require_erased_serialize_impl::&lt;T&gt;();
    }
    serialize_trait_object(serializer, <span class="self">self</span>.id(), <span class="self">self</span>)
  }
}

<span class="kw">impl</span>&lt;<span class="lifetime">'de</span>&gt; Deserialize&lt;<span class="lifetime">'de</span>&gt; <span class="kw">for </span>Box&lt;<span class="kw">dyn </span>Example&gt; {
  <span class="kw">fn </span>deserialize&lt;D: Deserializer&lt;<span class="lifetime">'de</span>&gt; &gt;(deserializer: D) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, D::Error&gt; {
    EXAMPLE_REGISTRY.deserialize_trait_object(deserializer)
  }
}

<span class="comment">// Run serialization roundtrip

</span><span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>std::error::Error&gt;&gt; {
  <span class="kw">let </span>examples: Vec&lt;Box&lt;<span class="kw">dyn </span>Example&gt;&gt; = <span class="macro">vec!</span>[Box::new(Foo(<span class="string">"A"</span>.to_string())), Box::new(Bar(<span class="number">0</span>))];
  <span class="macro">println!</span>(<span class="string">"Examples: {:?}"</span>, examples);
  <span class="kw">let </span>json = serde_json::to_string(<span class="kw-2">&amp;</span>examples)<span class="question-mark">?</span>;
  <span class="macro">println!</span>(<span class="string">"Serialized: {}"</span>, json);
  <span class="kw">let </span>roundtrip: Vec&lt;Box&lt;<span class="kw">dyn </span>Example&gt;&gt; = serde_json::from_str(<span class="kw-2">&amp;</span>json)<span class="question-mark">?</span>;
  <span class="macro">println!</span>(<span class="string">"Deserialized: {:?}"</span>, roundtrip);
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Check out the examples for more use-cases:</p>
<ul>
<li><code>example/simple.rs</code>: A full version of the above example.</li>
<li><code>example/macros.rs</code>: Convenience macro layered on top of this crate, using <a href="https://crates.io/crates/linkme">linkme</a> to register types.</li>
<li><code>example/no_global.rs</code>: Use a local registry instead of a global one, using <a href="../serde/de/trait.DeserializeSeed.html" title="trait serde::de::DeserializeSeed"><code>DeserializeSeed</code></a> implementations
provided by this crate.</li>
<li><code>example/generic_instantiations.rs</code>: Create and use registries for <em>instantiations</em> of generic traits/structs.
Does not handle traits nor structs generically though!</li>
</ul>
<h2 id="limitations"><a class="doc-anchor" href="#limitations">§</a>Limitations</h2><h3 id="generic-serialization-and-deserialization"><a class="doc-anchor" href="#generic-serialization-and-deserialization">§</a>Generic Serialization and Deserialization</h3>
<p>Serialization and deserialization of trait objects with generic type parameters and structs with generic type
parameters is not supported, and I think it is impossible to support this. To support this, we would need a function
that goes from a run-time unique identifier (<code>&amp;str</code>) to a compile-time type, but that is impossible. This makes
sense, because the compiler needs to know at compile-time which (combination of) concrete types are used as generic
type arguments to do monomorphization.</p>
<p>However, it is possible to register all concrete instances of types that you wish to deserialize, as is done in
<code>example/generic_instantiations.rs</code>.</p>
<h3 id="other-representations"><a class="doc-anchor" href="#other-representations">§</a>Other Representations</h3>
<p>Only the <a href="https://serde.rs/enum-representations.html#externally-tagged">externally tagged enum representation</a> is supported for (de)serializing trait objects, to simplify
the implementations in this crate. This is only a problem if you need to accept serialized trait objects that were
serialized externally using a different representation (i.e., not this crate).</p>
<h2 id="inspiration"><a class="doc-anchor" href="#inspiration">§</a>Inspiration</h2>
<p>This crate is inspired by the excellent <a href="https://crates.io/crates/typetag">typetag</a> crate.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="de/index.html" title="mod serde_flexitos::de">de</a></div><div class="desc docblock-short"><a href="../serde/de/trait.DeserializeSeed.html" title="trait serde::de::DeserializeSeed"><code>DeserializeSeed</code></a> and <a href="../serde/de/trait.Visitor.html" title="trait serde::de::Visitor"><code>Visitor</code></a> impls for deserializing trait objects and collections of trait objects.</div></li><li><div class="item-name"><a class="mod" href="ser/index.html" title="mod serde_flexitos::ser">ser</a></div><div class="desc docblock-short"><a href="../serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize"><code>Serialize</code></a> implementation for serialization of trait objects.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.MapRegistry.html" title="struct serde_flexitos::MapRegistry">MapRegistry</a></div><div class="desc docblock-short"><a href="trait.Registry.html" title="trait serde_flexitos::Registry">Registry</a> implementation mapping unique identifiers of type [<code>I</code>] to deserialize functions of trait object type [<code>O</code>],
using a <a href="https://doc.rust-lang.org/1.80.1/alloc/collections/btree/map/struct.BTreeMap.html" title="struct alloc::collections::btree::map::BTreeMap">BTreeMap</a>.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.GetError.html" title="enum serde_flexitos::GetError">GetError</a></div><div class="desc docblock-short">Error while getting deserialize function.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Registry.html" title="trait serde_flexitos::Registry">Registry</a></div><div class="desc docblock-short">Registry mapping unique identifiers of types to their deserialize implementations, enabling deserialization of a specific
trait object type.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.serialize_trait_object.html" title="fn serde_flexitos::serialize_trait_object">serialize_trait_object</a></div><div class="desc docblock-short">Serialize <code>trait_object</code> of type <code>O</code> with <code>serializer</code>, using <code>id</code> as the unique identifier for the concrete type of
<code>trait_object</code>.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.DeserializeFn.html" title="type serde_flexitos::DeserializeFn">DeserializeFn</a></div><div class="desc docblock-short">Type alias for deserialize functions of trait object type <code>O</code>.</div></li></ul></section></div></main></body></html>